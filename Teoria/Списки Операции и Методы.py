map(int,input().split()) ##- метод split разбивает строку по пробелу,
map #применяет указанную функцию к каждому элементу последовательности.


randrange(num)
*a #- раскрывание итерируемого объекта

list(map(int,input().split())) #- список чисел
list(range(1, 5)) #- список из чисел от 1 до 4х

del b[2] #- удалить элемент списка по индексу 2
type() #- тип
len() #- в списке это количество элементов
[1,2,3]*3=[1,2,3,1,2,3,1,2,3]
[1,2,3]+[3]=[1,2,3,3]
2 in a #- присутствует ли 2 в списке а (True, False)
sum() #- сумма всех элементов
min,max #- минимальное и максимальное значение в списке


#добавить элемент в список:
a.append() #- добавить один элемент в конец списка
a +=[1,2,3]   #- добавить элементы в конец списка
#если добавить строку +="1,2,3" то добавится [1],[2],[3]
a.insert(2,100) #- вставить элемент 100 на 2 позицию, сдвигая другие позиции
# Если указан недопустимый индекс, то во время выполнения программы не происходит ошибки.
# Если задан индекс за пределами конца списка, то значение будет добавлено в конец списка.
# Если применен отрицательный индекс, который указывает на недопустимую позицию,
# то значение будет вставлено в начало списка.
a.extend(b) #- добавляет в конец списка a элементы списка b или можно добавить отдельный элемент
words1.append('python') - получим ['iq option', 'stepik', 'beegeek', 'python']
words2.extend('python') -  получим ['iq option', 'stepik', 'beegeek', 'p', 'y', 't', 'h', 'o', 'n']

#удалить элемент в списке:
a.remove() #- удаляет элемент, первый попавшийся подходящий элемент a[0] - удаляет первый элемент под индексом 0
del numbers[::2] #- удалить все элементы на четных позициях (0, 2, 4, ...) исходного списка.

#Сортировка:
sorted() #- сортировка, изначальный список не меняется
sorted(a,reverse=True) #- сортировка по убыванию
a.sort() #- сортирует список по возрастанию, изменяя изначальный список
a.sort(reverse=True) #- сортирует список по убыванию
a.reverse() #-  в обратном порядке список  - так же это можно сделать a[::-1]
sort #применяется только в списках
sorted() #- можно применять к любым итерабельным последовательностям(всё что можно обойти в цикле for)
#  но вернет все равно список

a.clear( ) #- очистить
a.copy() #- копия списка
a.count() #- сколько раз значение встречается в списке
a.index(12) #- поиск 12 по индексу слева направо
a.index(12,3) #- начиная с 3го
a.index(12,3,5) #- начиная с 3го и по 5й
(-a[:: -1] - 1).index(12) #- поиск индекса справа, тип например -1,-2,-3 и т.д
len(a) - a[:: -1].index(12) #- 1 - поиск индекса справа, тип например 8,9,10 и т.д

a.pop() или a.pop(3)   #- удаляет элемент и выводит на экран, по умолчанию последний

    #строковые методы(работают только со списком строк)
a.split() #- разбивает строку (по пробелам) на элементы и преобразует в список
a.split('.')  #- разбивает строку на элементы по '.'
a.split('\\') #- что бы разделить по слэшам \ - нужно ставить двойной сллэш
' '.join(a) #- собирает элементы списка в строку разделяя их ' '
s.split() и s.split(' ') #- не одно и то же, второй вариант не уберет все пробелы, если их несколько подряд.

*a, b, c = [1, 2, 3, 4]   - * - #присваивает несколько значений (список) одной переменной
print(*mas) - * #распаковка списка в отдельные элементы
пример:
mas=[1,2,3, "опа"]
print(*mas) - #распакуется как 1 2 3 опа , а не ['1','2','3','опа']


            

                #ФУНКЦИЯ ГЕНЕРАТОР - list comprehensions:
#Пример1
def genf():
    for i in [42,64,55]:
        yield i # функция yield возвращает значение и замораживает вашу функцию
        # со всеми значениями на этом месте

#1) s=genf():

#2) for i in genf():
     #print(i)


#Пример2
def genf():
    s=7
    for i in [42,64,55]:
        yield i # функция yield возвращает значение и замораживает вашу функцию
        # со всеми значениями на этом месте
        print(s)
        s=s*10+7

g=genf()
print(next(g)) #выводит 42 - первое значение i
print(next(g)) #выводит 7 - s=7
print(next(g)) #выводит 64 - второе значение i
print(next(g)) #выводит 77- s=7*10+7

#функция факториала:
def fact(n):  # Обычная функция факториала
    pr=1
    a=[]
    for i in range(1,n+1):
        pr=pr*i
        a.append(pr)
    return a
print(fact(10))


def fact(n):  # функция генератор факториала
    pr=1
    for i in range(1,n+1):
        pr=pr*i
        yield pr
#s=fact(10)
#print(next(s))
#print(next(s))
#print(next(s))
for i in fact(10):
    print(i, end=' ')

    #РАСКРЫТИЕ МНОГОМЕРНОГО СПИСКА В ОДНОМЕРНЫЙ С ПОМОЩЬЮ ГЕНЕРАТОРА СПИСКОВ - list comprehensions
new_list  = [sub_list_3 for sub_list_1 in original_list for sub_list_2 in sub_list_1 for sub_list_3 in sub_list_2]
